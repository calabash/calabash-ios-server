//
//  LPExitRoute.m
//  calabash
//
//  Created by Trevor Harmon on 11/15/12.
//  Copyright (c) 2012 Xamarin. All rights reserved.
//

#import "LPExitRoute.h"

@implementation LPExitRoute

- (BOOL) supportsMethod:(NSString *) method atPath:(NSString *) path {
  return [method isEqualToString:@"GET"] || [method isEqualToString:@"POST"];
}


- (NSDictionary *) JSONResponseForMethod:(NSString *) method URI:(NSString *) path data:(NSDictionary *) data {
  // Exiting the app causes the HTTP connection to shutdown immediately.
  // Clients will get an empty response and need to handle the error
  // condition accordingly.

/*
 https://developer.apple.com/library/ios/qa/qa1561/_index.html
 Q:  How do I programmatically quit my iOS application?

 A: There is no API provided for gracefully terminating an iOS application.

 In iOS, the user presses the Home button to close applications. Should your
 application have conditions in which it cannot provide its intended function,
 the recommended approach is to display an alert for the user that indicates the
 nature of the problem and possible actions the user could take â€” turning on
 WiFi, enabling Location Services, etc. Allow the user to terminate the
 application at their own discretion.

 Warning: Do not call the exit function. Applications calling exit will appear
 to the user to have crashed, rather than performing a graceful termination and
 animating back to the Home screen.

 Additionally, data may not be saved, because -applicationWillTerminate: and
 similar UIApplicationDelegate methods will not be invoked if you call exit.

 If during development or testing it is necessary to terminate your application,
 the abort function, or assert macro is recommended.

 $ xcrun man abort
 The abort() function causes a report to be generated by Crash Reporter.  If you
  wish to terminate without generating a crash
 report, use exit(3) instead.

 Is it me or do the docs contradict each other?

 exit(3) => "exited abnormally with exit status 3"
 exit(0) => < no output >
*/
  NSLog(@"Received http exit.");

  // See discussion above.
  int exitCode = 0;
  NSNumber *payloadExitCode = [data objectForKey:@"exit_code"];
  if (payloadExitCode) {
    exitCode = [payloadExitCode intValue];
  }

  NSTimeInterval defaultDelay = 0.4;

  NSTimeInterval postResignActiveDelay = defaultDelay;
  NSTimeInterval postWillTerminateDelay = defaultDelay;

  NSNumber *payloadDelay = [data objectForKey:@"post_resign_active_delay"];
  if (payloadDelay) {
    postResignActiveDelay = [payloadDelay doubleValue];
  }

  payloadDelay = [data objectForKey:@"post_will_terminate_delay"];
  if (payloadDelay) {
    postWillTerminateDelay = [payloadDelay doubleValue];
  }

  UIApplication *shared = [UIApplication sharedApplication];

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wundeclared-selector"
  SEL willTerminate = @selector(applicationWillTerminate);
  SEL terminateWithSuccess = @selector(terminateWithSuccess);
#pragma clang diagnostic pop

  SEL applicationWillResignActive = @selector(applicationWillResignActive:);

  id<UIApplicationDelegate>appDelegate = [shared delegate];
  if ([appDelegate respondsToSelector:applicationWillResignActive]) {
    NSLog(@"Calling [[UIApplication delegate] applicationWillResignActive] after a delay of %@ s",
    @(postWillTerminateDelay));
    [appDelegate applicationWillResignActive:shared];
  } else {
    NSLog(@"Application delegate does not respond to selector '%@'; skipping.",
          NSStringFromSelector(applicationWillResignActive));
  }

  if ([shared respondsToSelector:willTerminate]) {
    NSLog(@"Calling [UIApplication willTerminate].");
    [shared performSelector:willTerminate withObject:nil afterDelay:postResignActiveDelay];
  } else {
    NSLog(@"UIApplication does not respond to selector '%@'; skipping.",
    NSStringFromSelector(willTerminate));
  }

  if ([shared respondsToSelector:terminateWithSuccess]) {
    NSLog(@"Calling [UIApplication terminateWithSuccess] after a delay of %@ s", @(postWillTerminateDelay));
    [shared performSelector:terminateWithSuccess withObject:nil afterDelay:defaultDelay];
  } else {
    NSLog(@"UIApplication does not respond to selector '%@'", NSStringFromSelector(terminateWithSuccess));
    NSLog(@"Exiting with code %@", @(exitCode));
    exit(exitCode);
  }

  // Unreachable, but compiler complains.
  return @{};
}

@end
